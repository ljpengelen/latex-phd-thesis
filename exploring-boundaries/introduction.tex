\section{Introduction}
\label{sec:exploring-boundaries:Introduction}
Model-driven software engineering (MDSE) is a software engineering paradigm in which models play a central role throughout the entire development process~\cite{Schmidt2006}.
MDSE combines domain-specific modeling languages (DSMLs) for modeling at a higher level of abstraction and model transformations for the automated generation of various artifacts, such as code, from these models.
Our goal is to generate reliable code from models specified using a DSML.
To increase the reliability of generated code, formal methods such as verification can be used.
Model checking is an automated verification technique that checks whether a formally specified property holds for a model of a system~\cite{Clarke1999}.
An exhaustive state-space search is performed by an automated model checker to determine whether a property holds in a finite-state model of a system.
Often, this state space is huge and model checking is no longer a feasible approach for verification.
Traditionally, abstractions and simplifications are applied to the model to enable model checking in such cases~\cite{Chan1998,Clarke1994,Wing1995}.
We propose an MDSE approach to enable model checking that works the other way around.
Instead of starting with a large model and iteratively simplifying it, we start with a small model and iteratively refine it.

In a typical MDSE development process, domain-specific models are iteratively refined using model transformations until a model is acquired with enough details to implement a system~\cite{Kurtev2003}.
To increase the reliability of the final system, model checking can be employed.
Because of the aforementioned state-space explosion problem, model checking the final system may be infeasible.
Instead, we propose to define an additional model transformation that transforms the domain-specific models to models suitable for model checking.
Using this model transformation, model checking can be applied on the domain-specific models in every stage of the refinement process.
Using this approach, intermediate models close to the implementation can be model checked, while model checking the final system may be infeasible.
This chapter thus deals with research question~\RQ{2}.

\RQTwo

In this chapter, we demonstrate this approach using the Simple Language of Communicating Objects~(\SLCO), the DSML for modeling systems consisting of concurrent, communicating objects described in Chapter~\ref{chap:SLCO}.
\SLCO has an intuitive graphical syntax to model the structure and behavior of a system, and offers constructs such as synchronous communication to make models concise.
As discussed in Section~\ref{sec:slco:endogenous}, we implemented a number of transformations that can be composed into sequences to transform models specified in \SLCO to \NQC, a restricted version of C~\cite{Baum2003}.
The semantic properties of \NQC and its implementation platform differ from those of \SLCO, which means that some constructs that are available in \SLCO have no direct counterparts in \NQC.
To enable transformation from \SLCO to the implementation platform, the semantic gaps between the two platforms need to be bridged~\cite{Amstel2008}.
Therefore, we added a number of constructs to \SLCO and implemented a number of endogenous transformations~\cite{Mens:2006:TMT:1706639.1706924} that can be used to stepwise refine models to align the semantic properties of the DSML with \NQC.
These transformations replace the constructs in a model that are not offered by \NQC by constructs that it does offer, while preserving the observable behavior of the model.
A final exogenous transformation transforms the resulting model to executable code.

In Section~\ref{subsubsec:slco:transformation-to-promela}, the transformation from \SLCO to \Promela is described.
\Promela is the language of the model checker \Spin~\cite{Holzmann2003}, and this transformation is used to enable model checking of the (intermediate) domain-specific models.
Our first experiments showed that verification of models generated by sequences of refining, endogenous transformations using \Spin was infeasible due to state-space explosion, even for small source models, as described in Section~\ref{subsec:exploring-boundaries:results}.
We concluded that the change induced on the models by the transformations was too large.
In other words, the sequences of transformations were too coarse-grained.
Therefore, we split up the coarse-grained sequences of transformations into more fine-grained ones.
The impact of the individual transformations of such a fine-grained sequence of transformations on a model is smaller, and the model does not change drastically.
This is reflected in the increase of the state space size that is searched by \Spin.
Using this approach, intermediate models generated by the fine-grained sequences of transformations can be model checked almost all the way up to the models that can be executed because the state space stays within reasonable~bounds.

The remainder of this chapter is structured as follows.
Our approach to enable model checking of intermediate models on the lowest possible level of abstraction is discussed in Section~\ref{sec:exploring-boundaries:Approach}.
Section~\ref{sec:exploring-boundaries:comparison-of-transformations} compares the coarse-grained and fine-grained sequences of transformations that can be used to refine the models created with \SLCO.
The experiments we conducted are presented in Section~\ref{sec:exploring-boundaries:Experiments}.
In Section~\ref{sec:exploring-boundaries:Discussion}, we reflect on our work, and Section~\ref{sec:exploring-boundaries:Related_Work} describes related work.
Conclusions and directions for further research are given in Section~\ref{sec:exploring-boundaries:Conclusions_and_Future_Work}. 