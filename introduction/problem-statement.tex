\section{Problem Statement}
\label{sec:introduction:problem-statement}

%% Formele syntax en semantiek

There are a number of prerequisites for automatically generating reliable software from high-level descriptions.
One of the prerequisites is that the models that form these descriptions should provide an unambiguous specification of the systems they describe.
The need for unambiguous models can only be satisfied if the DSML used to specify these models has a formal syntax and semantics.
%Although we want to design a DSML with a \UML-like graphical syntax consisting of multiple views on models, the inconsistencies often caused by multiple views~\cite{Finkelstein:1994:IHM:630810.631143} do not pose problems in this case.
%For \SLCO, these views are only meant to visualize various aspects of models and not to construct models.
%We assume that the developers are able to create models that are both consistent and complete given an unambiguous DSML, without any further tools or techniques.
%For small cases, such as the ones described in this thesis, this is a reasonable assumption.

%% De DSML moet geschikte constructies bieden om de gewenste systemen te beschrijven.

Additionally, to successfully describe systems on a high level of abstraction using a DSML, this language must offer all the appropriate constructs for the domain at hand.
This means that the desired behavior and structure of the resulting software must be expressible in the DSML that is used to describe this software.

%% Automatisch generen van implementaties door het toepassen van de juiste model transformaties
%

Furthermore, to automatically generate software implemented using constructs on a low level of abstraction from designs using concepts on a high level of abstraction, refining model transformations are needed that add implementation details to the models that form these designs.
Instead of interpreting a model and manually constructing the corresponding implementation, a software engineer can then generate an implementation from a model by applying one or more model transformations.
Implementation details are added to the model in each transformation step, until the resulting model contains sufficient details for deployment on an execution platform.

%% verifieerbaarheid van modellen in een vroeg stadium van het ontwerp

Because models and model transformations are the primary artifacts in MDSE, being able to validate them during all phases of their development is another important prerequisite.
One way of validating models entails using existing languages and tools.
By transforming DSML models to models supported by existing tools, these tools can be used for the validation of (parts of) the DSML models.
For instance, model~\Model{POOSL} shown in Figure~\ref{fig:introduction:dsml-to-poosl} can be used to simulate model~\Model{SLCO}, and~\Model{Spin} can be used to simulate or verify \Model{SLCO}.
However, the usefulness of this transformational approach to validation is directly related to the correspondence between the DSML and the languages used for validation.
Only those constructs of a DSML that have a counterpart in the languages used for validation can be translated, and only the translatable parts of a DSML model can be validated using the tools for these languages.
If not all constructs of a DSML have counterparts in existing languages, custom tools, for instance for the generation and visualization of state spaces, are needed that are specifically built for the validation of DSML models.

\begin{figure}[hbt]
 \centering
 \includegraphics[scale=0.7]{introduction/figs/dsml-small-steps}
 \caption{Generating an implementation in small steps}
 \label{fig:introduction:small-steps}
\end{figure}

%% verifieerbaarheid van transformaties in een vroeg stadium van het ontwerp

Because we add implementation details to models using refining model transformations only, these transformations form a significant part of the design of the resulting software.
When generating software by applying model transformations to an initial model, this model and the applied model transformations together define the resulting software in its entirety.
Early validation of model transformations is therefore equally important as early validation of models.
The validation of model transformations is meant to assess whether these transformations correctly refine models.
For each source model and a set of properties that hold for this model, a refining transformation is considered to be correct if the properties also hold for the target model.
In this way, an implementation of a system satisfying certain properties can be generated by refining an abstract model that forms the design of this system, if this model satisfies the given properties.

To simplify the development and validation of model transformations, we decompose the transformations into small steps.
Splitting a monolithic transformation into smaller steps naturally results in multiple intermediate models, and we propose to use these models to develop and validate the transformations.
Figure~\ref{fig:introduction:small-steps} shows how the transformation from model~\Model{SLCO} to implementation~\Implementation{} is split into three steps.
The refining transformations~\NumberedTransformation{R}{1} and~\NumberedTransformation{R}{2} add implementation details to model~\SLCOModel{1}, which results in model~\SLCOModel{3}.
This model contains enough implementation details to be straightforwardly transformed to implementation~\Implementation{}.
Together, transformations~\NumberedTransformation{R}{1}, \NumberedTransformation{R}{2}, and~\Transformation{S2I} of Figure~\ref{fig:introduction:small-steps} replace the monolithic transformation~\Transformation{S2I} of Figure~\ref{fig:introduction:dsml-to-poosl}.
Analysis of model~\SLCOModel{1} and the intermediate models~\SLCOModel{2} and~\SLCOModel{3} provides additional insight into the transformation process that can be used for the development and validation of the transformation from \SLCO models to implementations.
The approach using the monolithic transformation illustrated in Figure~\ref{fig:introduction:dsml-to-poosl} does not offer this insight.

Finally, the fact that a model transformation correctly refines a single given model does not guarantee that it can be applied successfully to any possible model.
Applying a model transformation to a source model and then comparing the source and target model provides useful information for the developer of the transformation, but it does not prove any properties of this transformations.
To ensure that a sequence of refining model transformations leads to a correct implementation for any model it is applied to, the correctness of all model transformations in the sequence must be established. 